clc
clear all
% 1. Load and convert
img = imread('task2_Depth.png');
hsvImg = rgb2hsv(img);

% 2. Define thresholds for "Block Red/Orange"
% Hue is 0 to 1. Red is usually < 0.05 or > 0.95.
hueMin = 0.00;
hueMax = 0.10; % Adjust this to capture more orange or less red
satMin = 0.50; % Ignore "washed out" colors
valMin = 0.40; % Ignore very dark areas (the black voids)

% 3. Create the Mask
% This logical operation finds pixels that meet ALL our color criteria
mask = (hsvImg(:,:,1) >= hueMin & hsvImg(:,:,1) <= hueMax) & ...
(hsvImg(:,:,2) >= satMin) & ...
(hsvImg(:,:,3) >= valMin);

% 4. Clean up the foreground noise
% Use 'imopen' to remove small stray colored pixels in the foreground
se = strel('disk', 3);
cleanMask = imopen(mask, se);

% 5. Visualize the result
maskedImage = img;
maskedImage(repmat(~cleanMask, [1 1 3])) = 0; % Turn non-block pixels black

imshow(maskedImage);
title('Isolated Blocks (Foreground Colors Removed)');


% 1. Load the image
img = imread('task2_Depth.png');

% 2. Convert to grayscale to represent relative depth
% (Note: If you have the raw .mat or 16-bit depth file, use that instead!)
depthMap = rgb2gray(maskedImage);
imshow(depthMap)

% 3. Segment the blocks
% Looking at your image, the blocks are bright/distinct.
% We'll use a threshold. Adjust 0.6 if it picks up too much background.
bw = imbinarize(depthMap, 'adaptive', 'Sensitivity', 0.6);

% Clean up noise (remove small spots)
bw = bwareaopen(bw, 50);
imshow(bw)

% 4. Identify individual blocks
stats = regionprops('table', bw, depthMap, 'Centroid', 'MeanIntensity', 'PixelValues');

% 5. Display Results

% sensor's range
minDist = 0; % cm
maxDist = 53.5; % cm

for i = 1:height(stats)
val = stats.MeanIntensity(i);
% Convert intensity to a distance estimate
realDist = minDist + (val/(125)) * (maxDist - minDist);

if val > 110 && val < 125
fprintf('Block found with height %.3f\n', realDist);
end
end
